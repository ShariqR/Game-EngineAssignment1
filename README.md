Note: Build was too big to submit as a Release, Google drive link: https://drive.google.com/file/d/1-OBMoMYRRAmuyc6DjHPTAagnpbV_AgRf/view?usp=sharing

Interactive Media Scenario:
The Interactive Media Scenario we have created is a 2D SideScroller in Unity. The purpose of the scenario is to create a prototype that satisfies the requirements in Assignment 1. In this game, you as the player (a white square) are able to jump, fire different types of bullets, collect pickups to gain score or health, and take damage from objects on the ground. The user must pick up points in order to receive an achievement. Eventually, there will be enemies the player must fight while collecting points in order to complete the level.
Each member contributed an equal amount to the assignment (33.33% each), and worked together to achieve what was completed in the assignment.


AudioManager: This is a singleton that can easily manage SFX in-game. It Inherits from the Singleton class which sets an instance so that only one of it exists and it does not get destroyed, otherwise if it already exists, it destroys itself so that only one of its kind exists. The PlaySFX() method takes an audio clip, and if no audio source is chosen (from the empty object AudioManager is attached to), it returns null. Otherwise, it plays the sound effect. This makes SFX easier to manage as it's all called from one place, thus reducing the amount of code.
FireCommand: This is a command pattern that takes the RigidBody2D of an object (in this game, on the player), a bullet created from the BulletFactory Script, a integer bulletSpeed, the direction the rigidbody is facing, and what type of bullet is being fired. Using the Execute() method, it creates an instance of a bullet from BulletFactory, adds a RigidBody2D on it, and fires the bullet from the first RigidBody’s position, and in the direction given in the script using the speed. If no direction is given (ex. When the player first spawns in), it automatically shoots right. This helps to standardize and structure code as it has its own file, rather than being in PlayerController. As well, it allows this functionality to be passed onto other objects/classes like enemies if that functionality is desired in the future, as this can be called from anywhere.
DashCommand: This is a command pattern similar to Fire Command, which takes the RigidBody2D of an object (in this game, the player), the direction it is facing, and an integer dashSpeed. Using the Execute() method, it adds an impulse force to the object the RigidBody2D is attached to based off of the direction given and the dashSpeed value. This allows the object to perform a dash function. If the Undo() Method is called, it performs a dash in the opposite direction. This also helps to standardize and structure code rather than being in PlayerController. As with FireCommand, this allows this functionality to be passed onto other objects/classes like enemies if that functionality is desired in the future, as this can be called from anywhere.
BulletFactory: This is a Factory Pattern that creates different types of bullets that can be fired when the Execute() function from the FireCommand script is called. It contains an Enum with BulletType Normal and Large, which based off of the game objects chosen in the inspector and the switch case and with the CreateBullet() Method,  can create different types of Bullet instances that can be fired when the Execute() method is called from FireCommand. This helps as this allows us to create new BulletTypes that can be called with minimal additional code. For example, if we wish to add a new bullet, we can add another enum which can be called, add a new prefab to the inspector, and from PlayerController, you can simply call FireCommand’s Execute() method with the same parameters + the new BulletType.

Command Design Pattern (Scene Loading):
The implementation of the scene loader makes a great use of making transitions within loading different instances of levels by also organizing scenes accordingly to allow more ease of use for programming.
The primary reason to why the command design pattern was used within a scene loader is for the benefit of later on including implementations of further scenes examples such as: New levels, reloading levels from a lose state; The implementation of having it within a scene manager making more clean and efficient to reusing the pre-existing scripts for loading in new scenes as a way of not having the need of making amendments with the code, while also making it more simplified for extending functionality.

Singleton Design Pattern (Player Controller & Scene Manager):
Within the player controller, the implementation of the Singleton was used to ensure that there was only one instance of a player having accessibility to controls and functionalities of the attributes such as: movement, firing, health, dashing, etc;
The Singleton ensures that all implementations being within the player controller is only instanced only once and remains available for transitioning between scenes especially for the sole purpose of a 2D-platformer game, while also being a centralized point as mentioned before making it encapsulated within one class as a whole.
Within the scene manager, was also another implementation of the singleton in which was used for the scene manager and was integrated because similarly to the command design pattern, it allows to prevent creating multiple instances of the menu being replicated into different scenes.
