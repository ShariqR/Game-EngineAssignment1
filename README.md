Note: Build was too large, we created a google drive link with the videos and the UML Diagram:

Interactive Media Scenario:
The Interactive Media Scenario we have created is a 2D SideScroller in Unity. The purpose of the scenario is to create a prototype that satisfies the requirements in Assignment 1. In this game, you as the player (a white square) are able to jump, fire different types of bullets, collect pickups to gain score or health, and take damage from objects on the ground. The user must pick up points in order to receive an achievement. Eventually, there will be enemies the player must fight while collecting points in order to complete the level.
Each member contributed an equal amount to the assignment (33.33% each), and worked together to achieve what was completed in the assignment.


AudioManager: This is a singleton that can easily manage SFX in-game. It Inherits from the Singleton class which sets an instance so that only one of it exists and it does not get destroyed, otherwise if it already exists, it destroys itself so that only one of its kind exists. The PlaySFX() method takes an audio clip, and if no audio source is chosen (from the empty object AudioManager is attached to), it returns null. Otherwise, it plays the sound effect. This makes SFX easier to manage as it's all called from one place, thus reducing the amount of code.
FireCommand: This is a command pattern that takes the RigidBody2D of an object (in this game, on the player), a bullet created from the BulletFactory Script, a integer bulletSpeed, the direction the rigidbody is facing, and what type of bullet is being fired. Using the Execute() method, it creates an instance of a bullet from BulletFactory, adds a RigidBody2D on it, and fires the bullet from the first RigidBody’s position, and in the direction given in the script using the speed. If no direction is given (ex. When the player first spawns in), it automatically shoots right. This helps to standardize and structure code as it has its own file, rather than being in PlayerController. As well, it allows this functionality to be passed onto other objects/classes like enemies if that functionality is desired in the future, as this can be called from anywhere.
DashCommand: This is a command pattern similar to Fire Command, which takes the RigidBody2D of an object (in this game, the player), the direction it is facing, and an integer dashSpeed. Using the Execute() method, it adds an impulse force to the object the RigidBody2D is attached to based off of the direction given and the dashSpeed value. This allows the object to perform a dash function. If the Undo() Method is called, it performs a dash in the opposite direction. This also helps to standardize and structure code rather than being in PlayerController. As with FireCommand, this allows this functionality to be passed onto other objects/classes like enemies if that functionality is desired in the future, as this can be called from anywhere.
BulletFactory: This is a Factory Pattern that creates different types of bullets that can be fired when the Execute() function from the FireCommand script is called. It contains an Enum with BulletType Normal and Large, which based off of the game objects chosen in the inspector and the switch case and with the CreateBullet() Method,  can create different types of Bullet instances that can be fired when the Execute() method is called from FireCommand. This helps as this allows us to create new BulletTypes that can be called with minimal additional code. For example, if we wish to add a new bullet, we can add another enum which can be called, add a new prefab to the inspector, and from PlayerController, you can simply call FireCommand’s Execute() method with the same parameters + the new BulletType.

Command Design Pattern (Scene Loading):
The implementation of the scene loader makes a great use of making transitions within loading different instances of levels by also organizing scenes accordingly to allow more ease of use for programming.
The primary reason to why the command design pattern was used within a scene loader is for the benefit of later on including implementations of further scenes examples such as: New levels, reloading levels from a lose state; The implementation of having it within a scene manager making more clean and efficient to reusing the pre-existing scripts for loading in new scenes as a way of not having the need of making amendments with the code, while also making it more simplified for extending functionality.

Singleton Design Pattern (Player Controller & Scene Manager):
Within the player controller, the implementation of the Singleton was used to ensure that there was only one instance of a player having accessibility to controls and functionalities of the attributes such as: movement, firing, health, dashing, etc;
The Singleton ensures that all implementations being within the player controller is only instanced only once and remains available for transitioning between scenes especially for the sole purpose of a 2D-platformer game, while also being a centralized point as mentioned before making it encapsulated within one class as a whole.
Within the scene manager, was also another implementation of the singleton in which was used for the scene manager and was integrated because similarly to the command design pattern, it allows to prevent creating multiple instances of the menu being replicated into different scenes.

Health UI (Observer)
This is an implementation of the observer pattern, used to notify and update the HealthUI class based on changes to the player’s health in the PlayerController class. The PlayerController class extends the abstract Subject class which is used to add an observer, HealthUI, which implements the IObserver interface. When the TakeDamage or Heal function is called, the HealthUI class is notified and the health variable is passed through, which updates the health bar UI element accordingly. This allows for seamless and efficient tracking and updating of the player’s health values, which lets the UI elements reflect those changes.

Coin Score (Observer)
This is an implementation of the observer pattern, used to notify and update the ScoreUI class. The GameManager class extends the Subject class, and receives updates to the current score when coins are collected. The ScoreUI class implements the IObserver interface, which allows it to subscribe to the GameManager class. When notified, it passes the updated score from the GameManager and displays it on the UI element text box. This lets the score UI be updated efficiently as coins are collected, also bypassing the use of the PlayerController in this functionality. 

Achievement Tracker (Observer)
This is an implementation of the observer pattern, in this case, it is used to display an achievement notification when the AchievementTracker class is notified. The AchievementTracker class implements the IObserver interface, and subscribes to the GameManager’s notifications of the updated score. When the score reaches above 50, the achievement is displayed, showing the text box UI element containing the achievement message. This allows for an efficient way to track the progress of the achievement and display the corresponding message.

Game manager (Singleton)
This is an implementation of the singleton pattern, which ensures that there is only one instance of the GameManager class at all times. The GameManager is responsible for tracking the score of the player and facilitating the observer link between the ScoreSubject and ScoreUI classes.

CollectibleFactory (Factory)
This is an implementation of the factory pattern, which spawns either health pickups or coins on an instance of the CollectibleSpawner in-scene. In the CollectibleFactory class, there is an enum containing the collectible types (coin or health) which is used in a switch statement to select either of the 2 collectible types to spawn, based on the selection made in the inspector window. Both pickups extend the abstract class CollectibleBase, which contains the basic OnTriggerEnter functionality necessary to register the pickups, as well as a blank Collect function which allows each pickup to specify the functionality based on what it needs. Using the factory pattern for the collectibles allows for modular implementations, in case we would like to add any more collectibles, the functionality is already there. 
